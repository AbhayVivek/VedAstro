@using Genso.Astrology.Library
@using System.Xml.Linq
@using Tools = Genso.Astrology.Library.Tools
@using System.Text

<style>


    #DasaViewHolder {
        text-align: center;
        color: ivory;
        z-index: 1;
        cursor: pointer;
    }

</style>


<div class="vstack gap-1" style="width: fit-content;">
    <div class="hstack gap-2">
        <div>
            <label>Start</label>
            <input @bind="_startYearInput" type="text" class="form-control">
        </div>
        <div>
            <label>End</label>
            <input @bind="_endYearInput" type="text" class="form-control">
        </div>
        <div>
            <label>Day/Px</label>
            <input @bind="_daysPerPixelInput" type="text" class="form-control">
        </div>

        <IconButton OnClickCallback="@OnClickRefreshButton" ButtonText="Refresh" IconName="bi:send-check" />
    </div>
    @*ID set because used by auto move cursor line handler*@
    <div class="container-xxl" @ref="_dasaViewBox" style="overflow-x: scroll; height: 280px;">@DasaReportSvg</div>
@*    <div style="background-color: cadetblue;" class="fw-bold hstack"><p id="TimeCursorLegend"></p></div>*@    
    <ul class="list-group" style="font-weight: bold;">
        <li class="list-group-item active" aria-current="true">Time : <span id="DateLegend"></span></li>
        <li class="list-group-item">Age : <span id="AgeLegend"></span></li>
        <li class="list-group-item">Dasa : <span id="DasaLegend"></span></li>
        <li class="list-group-item">Bhukti : <span id="BhuktiLegend"></span></li>
        <li class="list-group-item">Antaram : <span id="AntaramLegend"></span></li>
        <li class="list-group-item">Gochara : <span id="GocharaLegend"></span></li>
    </ul>

</div>


@code {

    string? _startYearInput, _endYearInput;
    double _daysPerPixelInput = 30;

    /// <summary>
    /// One precision value for generating all dasa components,
    /// because misalignment occurs if use different precision
    /// </summary>
    //static double _eventsPrecision = Tools.DaysToHours(14);

    //double _timeSlicePrecision = _eventsPrecision;

    ElementReference _dasaViewBox;

    //px width & height of each slice of time
    //used when generating dasa rows
    //note: changes needed only here
    int _widthPerSlice = 1;
    int _heightPerSlice = 35;



    //PROPERTIES
    private Person Person { get; set; }

    private List<Event>? DasaEventList { get; set; }

    private List<Event>? BhuktiEventList { get; set; }

    private List<Event>? AntaramEventList { get; set; }

    private MarkupString DasaReportSvg { get; set; } = new("");






    //█▀█ █▀█ █ █░█ ▄▀█ ▀█▀ █▀▀   █▀▄▀█ █▀▀ ▀█▀ █░█ █▀█ █▀▄ █▀
    //█▀▀ █▀▄ █ ▀▄▀ █▀█ ░█░ ██▄   █░▀░█ ██▄ ░█░ █▀█ █▄█ █▄▀ ▄█

    /// <summary>
    /// Sets the data that is processed and fill the content
    /// </summary>
    public async Task SetData(Person person)
    {
        //save inputed data
        this.Person = person;

        //to minimize UX friction, default time range for dasa view is used first
        //user can adjust later, birth year to current year plus 2 is default for now
        _startYearInput = this.Person.BirthYear.ToString();
        _endYearInput = (this.Person.BirthYear + 120).ToString();


        await DrawReport(GetDayPerPixel());

        //attach handlers now that component is loaded
        //attach mouse handler to auto move cursor line & update time legend
        await _jsRuntime.AddEventListener(_dasaViewBox, "mousemove", "onMouseMoveDasaViewEventHandler");
        //init touch for the dasa chart
        await _jsRuntime.InvokeVoidAsync("InitTouchLib", _dasaViewBox);


        //needed to show changes to inputs
        StateHasChanged();
    }

    private double GetDayPerPixel()
    {

        var dif = double.Parse(_endYearInput) - double.Parse(_startYearInput);
        dif++; //add 1 to count the years it self 2020 -2021 = 365*2
        var daysBetween = dif * 365;
        var maxWidth = 1000;
        var daysPerPixel = Math.Round(daysBetween / maxWidth, 3); //small val = higher precision
                                                                  //var daysPerPixel = Math.Round(yearsBetween * 0.4, 3); //small val = higher precision
                                                                  //daysPerPixel = daysPerPixel < 1 ? 1 : daysPerPixel; // minimum 1 day per px

        return daysPerPixel;

    }

    private async Task DrawReport(double daysPerPixel = 0)
    {
        //generate dasa report in svg from server
        var startTime = new Time($"00:00 01/01/{_startYearInput} {Person.BirthTimeZone}", Person.GetBirthLocation());
        var endTime = new Time($"11:59 31/12/{_endYearInput} {Person.BirthTimeZone}", Person.GetBirthLocation());

        _daysPerPixelInput = daysPerPixel != 0 ? daysPerPixel : _daysPerPixelInput; //if not defined, use input
        var finalSvg = await GetDasaReportSvgFromApi(this.Person, startTime, endTime, _daysPerPixelInput);

        //inject new svg into page via JS for a more responsive progress update
        //doing it in blazor, causes progress bar freeze while updating
        await _jsRuntime.InjectIntoElement(_dasaViewBox, finalSvg);

    }

    /// <summary>
    /// Contacts API and gets Person Dasa Report in svg string
    /// Note:
    /// -previously used generate in blazor client,
    ///  but for speed (10s gain) sake moved to server to do heavy lifting
    /// </summary>
    private async Task<string> GetDasaReportSvgFromApi(Person inputPerson, Time startTime, Time endTime, double daysPerPixel)
    {
        //since majority of time spent will be waiting for API to do calculation
        //and receiving the image is fast, so just start an auto progress bar
        _jsRuntime.ProgressBarSlowAutoUpdate(); //do not await to let control go to next

        var personHashXml = new XElement("PersonHash", inputPerson.Hash);
        var startTimeXml = new XElement("StartTime", startTime.ToXml());
        var endTimeXml = new XElement("EndTime", endTime.ToXml());
        var daysPerPixelXml = new XElement("DaysPerPixel", daysPerPixel);
        var rootXml = new XElement("Root", personHashXml, startTimeXml, endTimeXml, daysPerPixelXml);
        //note: when calling this api via postman, svg needs to be parsed in boxy-svg before viewable
        var svgStream = await WriteToServerStreamResponse(ServerManager.GetPersonDasaReport, rootXml);

        //todo just send as string to remove lags of using stream
        // convert stream to string
        svgStream.Position = 0; //reset position otherwise can be null value out
        var reader = new StreamReader(svgStream);
        var svgText = await reader.ReadToEndAsync();

        return svgText;
    }

    /// <summary>
    /// Send xml as string to server and returns stream as response
    /// </summary>
    public static async Task<Stream> WriteToServerStreamResponse(string apiUrl, XElement xmlData)
    {
        //prepare the data to be sent
        var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, apiUrl);

        httpRequestMessage.Content = XmLtoHttpContent(xmlData);

        //get the data sender
        using var client = new HttpClient();

        //tell sender to wait for complete reply before exiting
        var waitForContent = HttpCompletionOption.ResponseContentRead;

        //send the data on its way
        var response = await client.SendAsync(httpRequestMessage, waitForContent);

        //extract the content of the reply data
        var rawMessage = response.Content.ReadAsStreamAsync().Result;

        return rawMessage;
    }

    /// <summary>
    /// Packages the data into ready form for the HTTP client to use in final sending stage
    /// </summary>
    private static StringContent XmLtoHttpContent(XElement data)
    {
        //gets the main XML data as a string
        var dataString = Tools.XmlToString(data);

        //specify the data encoding
        var encoding = Encoding.UTF8;

        //specify the type of the data sent
        //plain text, stops auto formatting
        var mediaType = "plain/text";

        //return packaged data to caller
        return new StringContent(dataString, encoding, mediaType);
    }

    private async Task OnClickRefreshButton(MouseEventArgs obj)
    {
        await _globalVariable.LoadingMessage.Show();

        await DrawReport(GetDayPerPixel());

        await _globalVariable.LoadingMessage.Hide();

    }

}

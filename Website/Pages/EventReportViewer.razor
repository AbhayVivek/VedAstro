@using Genso.Astrology.Library
@using System.Xml.Linq
@using Tools = Genso.Astrology.Library.Tools
@using System.Text


<div class="vstack gap-1" style="width: fit-content;">
    @*
    dark mode is disabled for chart with mix-blend-mode
    note: extra logic to remove filter in normal mode
    *@
    <div class="container-xxl" id="DasaViewBox" @ref="_dasaViewBox" style="margin-left: -11px; @(AppData.DarkMode?"mix-blend-mode: difference;":"")"></div>

    @*bottom chart options row*@
    <div class="hstack gap-3 mt-2">
        <IconButton @ref="_showButton" ButtonText="Life Events" IconName="clarity:eye-show-solid" OnClickCallback="OnClickShowLifeEvents" SmallSize="true" />
        <IconButton @ref="_hideButton" ButtonText="Life Events" IconName="clarity:eye-hide-solid" OnClickCallback="OnClickHideLifeEvents" SmallSize="true" />
        @*only show "Save" button if viewing newly generated chart, so that no erroneous double save*@
        @if (!_nowSavedChart)
        {
            <IconButton ButtonText="Save Chart" IconName="entypo:save" OnClickCallback="OnClickSaveChartAPI" SmallSize="true" />
        }
    </div>
</div>


@code {
    private bool _nowSavedChart = false; //set by show chart button

    public Person SelectedPerson { get; set; }

    ElementReference _dasaViewBox;
    public Time StartTime { get; set; }
    public Time EndTime { get; set; }
    public List<EventTag> InputedEventTags { get; set; }

    private IconButton _showButton;
    private IconButton _hideButton;

    /// <summary>
    /// Raw SVG string of the latest chart
    /// </summary>
    string _finalSvg;

    bool isDirty = true; //so that it runs on 1st render

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (isDirty)
        {
            //default show life event
            await OnClickShowLifeEvents();
            isDirty = false;//reset
        }
    }

    /// <summary>
    /// Sets the data that is processed and fill the content
    /// </summary>
    public async Task ShowChart(Person person, Time startTime, Time endTime, List<EventTag> inputedEventTags)
    {

        //saved to be accessed later
        SelectedPerson = person;
        StartTime = startTime;
        EndTime = endTime;
        InputedEventTags = inputedEventTags;

        //1 GENERATE CHART IN SVG FROM SERVER
        //saved for later use by Chart Saver
        _finalSvg = await GetDasaReportSvgFromApi(person, startTime, endTime, inputedEventTags);

        //2 LOAD CHART INTO PAGE
        await LoadChartIntoPage(_finalSvg);

        //set current chart as not from saved version
        _nowSavedChart = false;

        //needed to make save button appear again
        StateHasChanged();
    }

    private async Task<string> GetSavedDasaReportSvgFromApi(string chartHash)
    {
        var chartIdXml = new XElement("ChartHash", chartHash);
        var svgStream = await ServerManager.WriteToServerStreamReply(ServerManager.GetSavedPersonEventsReport, chartIdXml, _jsRuntime);

        //todo just send as string to remove lags of using stream (testing needed 1st, maybe same or faster)
        // convert stream to string
        svgStream.Position = 0; //reset position otherwise can be null value out
        var reader = new StreamReader(svgStream);
        var svgText = await reader.ReadToEndAsync();

        return svgText;

    }

    /// <summary>
    /// Contacts API and gets Person Dasa Report in svg string
    /// Note:
    /// -previously used generate in blazor client,
    ///  but for speed (10s gain) sake moved to server to do heavy lifting
    /// </summary>
    private async Task<string> GetDasaReportSvgFromApi(Person inputPerson, Time startTime, Time endTime, List<EventTag> inputedEventTags)
    {
        //auto calculate precision
        var daysPerPixelRaw = GetDayPerPixel(startTime, endTime);
        //if not defined, use input
        double daysPerPixelInput = 30;
        daysPerPixelInput = daysPerPixelRaw != 0 ? daysPerPixelRaw : daysPerPixelInput;


        var personIdXml = new XElement("PersonId", inputPerson.Id);
        var startTimeXml = new XElement("StartTime", startTime.ToXml());
        var endTimeXml = new XElement("EndTime", endTime.ToXml());
        var daysPerPixelXml = new XElement("DaysPerPixel", daysPerPixelInput);
        var eventTagListXml = EventTagExtensions.ToXmlList(inputedEventTags);
        var rootXml = new XElement("Root", personIdXml, startTimeXml, endTimeXml, eventTagListXml, daysPerPixelXml);
        //note: when calling this api via postman, svg needs to be parsed in boxy-svg before viewable
        var svgStream = await ServerManager.WriteToServerStreamReply(ServerManager.GetPersonEventsReport, rootXml, _jsRuntime);

        //todo just send as string to remove lags of using stream (testing needed 1st, maybe same or faster)
        // convert stream to string
        svgStream.Position = 0; //reset position otherwise can be null value out
        var reader = new StreamReader(svgStream);
        var svgText = await reader.ReadToEndAsync();

        return svgText;
    }

    private async Task<bool> SaveReportSvgInApi(Person inputPerson, Time startTime, Time endTime, List<EventTag> inputedEventTags)
    {
        //auto calculate precision
        var daysPerPixelRaw = GetDayPerPixel(startTime, endTime);
        //if not defined, use input
        double daysPerPixelInput = 30;
        daysPerPixelInput = daysPerPixelRaw != 0 ? daysPerPixelRaw : daysPerPixelInput;


        var personIdXml = new XElement("PersonId", inputPerson.Id);
        var startTimeXml = new XElement("StartTime", startTime.ToXml());
        var endTimeXml = new XElement("EndTime", endTime.ToXml());
        var daysPerPixelXml = new XElement("DaysPerPixel", daysPerPixelInput);
        var eventTagListXml = EventTagExtensions.ToXmlList(inputedEventTags);
        var rootXml = new XElement("Root", personIdXml, startTimeXml, endTimeXml, eventTagListXml, daysPerPixelXml);
        //note: when calling this api via postman, svg needs to be parsed in boxy-svg before viewable
        Console.WriteLine(rootXml.ToString());
        var result = await ServerManager.WriteToServerXmlReply(ServerManager.SavePersonEventsReport, rootXml, _jsRuntime);

        return Tools.IsResultPass(result);
    }

    /// <summary>
    /// Given a saved chart name in local storage, it will load it into page
    /// </summary>
    public async Task ShowSavedChart(string selectedChartHash)
    {
        //set current chart as from saved version (to hide save button)
        //only show "Save" button if viewing newly generated chart, so that no erroneous double save
        _nowSavedChart = true;

        //1 GENERATE CHART IN SVG FROM SERVER
        //saved for later use by Chart Saver
        _finalSvg = await GetSavedDasaReportSvgFromApi(selectedChartHash);

        //gets person profile used to generate the saved chart being showed now
        //needs to be set else parent depending will fail
        SelectedPerson = await WebsiteTools.GetPersonIdFromChartHash(selectedChartHash, _jsRuntime);

        //2 LOAD CHART INTO PAGE
        await LoadChartIntoPage(_finalSvg);

        //needed to make save button appear again
        StateHasChanged();

    }
    /// <summary>
    /// Given a saved chart name in local storage, it will load it into page
    /// </summary>
    public async Task ShowSavedChartOld(string selectedChartHash)
    {

        await _jsRuntime.ShowLoading();

        //set current chart as from saved version (to hide save button)
        //only show "Save" button if viewing newly generated chart, so that no erroneous double save
        _nowSavedChart = true;

        //gets person profile used to generate the saved chart being showed now
        //extract hash from chart name
        var raw = selectedChartHash.Split("|");
        var hash = raw[0]; //1st place is hard set hash
                           //get person from hash
        SelectedPerson = await WebsiteTools.GetPersonFromId(hash, _jsRuntime);

        //get raw chart
        _finalSvg = await _jsRuntime.GetProperty(selectedChartHash);

        //load chart into page
        await LoadChartIntoPage(_finalSvg);

        _jsRuntime.HideLoading();

    }

    /// <summary>
    /// Given an SVG as string, it will inject it into page & attach
    /// the needed JS handlers for animation
    /// </summary>
    private async Task LoadChartIntoPage(string rawSvgChart)
    {

        //inject new svg into page via JS for a more responsive progress update
        //doing it in blazor, causes progress bar freeze while updating
        await _jsRuntime.InjectIntoElement(_dasaViewBox, rawSvgChart);

        //little delay after injection for cpu to idle, make smooth transition
        await Task.Delay(300);

        //reset life show/hide button
        await OnClickShowLifeEvents();

        //attach tooltip lib for life events
        //note: needed on each draw
        await _jsRuntime.InvokeVoidAsync("InitLifeEventLineToolTip");


        //2 ATTACH HANDLERS NOW THAT COMPONENT IS LOADED

        //attach mouse handler to auto move cursor line & update time legend
        await _jsRuntime.InvokeVoidAsync("LoadEventDataListFile"); //load event description file 1st
        await _jsRuntime.AddEventListener(_dasaViewBox, "mousemove", "onMouseMoveDasaViewEventHandler");

        //attach handler to auto hide time legend
        await _jsRuntime.AddEventListener("#EventChartHolder", "mouseleave", "onMouseLeaveEventChart");

        //init touch for the dasa chart
        await _jsRuntime.InvokeVoidAsync("InitTouchLib", _dasaViewBox);

        //get latest dark mode setting
        //so that event chart is set properly
        await AppData.UpdateDarkMode(_jsRuntime);

        //needed to show changes to inputs
        StateHasChanged();

    }

    /// <summary>
    /// calculates the precision of the events to fit inside 1000px width
    /// </summary>
    public static double GetDayPerPixel(Time start, Time end)
    {
        const int maxWidth = 1000; //px

        var daysBetween = end.Subtract(start).TotalDays;
        var daysPerPixel = Math.Round(daysBetween / maxWidth, 3); //small val = higher precision
                                                                  //var daysPerPixel = Math.Round(yearsBetween * 0.4, 3); //small val = higher precision
                                                                  //daysPerPixel = daysPerPixel < 1 ? 1 : daysPerPixel; // minimum 1 day per px

        return daysPerPixel;
    }

    //█▀█ █▀█ █ █░█ ▄▀█ ▀█▀ █▀▀   █▀▄▀█ █▀▀ ▀█▀ █░█ █▀█ █▀▄ █▀
    //█▀▀ █▀▄ █ ▀▄▀ █▀█ ░█░ ██▄   █░▀░█ ██▄ ░█░ █▀█ █▄█ █▄▀ ▄█
    private async Task OnChangeLifeEventCheckBox(ChangeEventArgs obj)
    {
        //based on checked value hide or show
        if ((bool)obj.Value)
        {
            await _jsRuntime.Show("#LifeEventLinesHolder");
        }
        else
        {
            await _jsRuntime.Hide("#LifeEventLinesHolder");
        }
    }

    private async Task OnClickHideLifeEvents()
    {
        //hide & show the relevant buttons
        await _jsRuntime.Hide(_hideButton.ElementReference);
        await _jsRuntime.Show(_showButton.ElementReference);

        //hide element
        await _jsRuntime.Hide("#LifeEventLinesHolder");

    }

    //default to this, since api generates with events visible
    //set every time after svg injected
    private async Task OnClickShowLifeEvents()
    {
        //hide & show the relevant buttons
        await _jsRuntime.Hide(_showButton.ElementReference);
        await _jsRuntime.Show(_hideButton.ElementReference);

        //show element
        await _jsRuntime.Show("#LifeEventLinesHolder");

    }

    /// <summary>
    /// saves chart to server
    /// </summary>
    /// <returns></returns>
    private async Task OnClickSaveChartAPI()
    {
        //todo for some reason after click there still remains a lag
        await _jsRuntime.ShowLoading();

        //hold control until loading box popped
        await AppData.IfNoLoadingBoxPleaseHold();

        //tell server to generate & save this chart
        //give the server settings used to generate this chart
        var result = await SaveReportSvgInApi(SelectedPerson, StartTime, EndTime, InputedEventTags);

        _jsRuntime.HideLoading();


        //show message to user based on success or failure
        if (result) { await _jsRuntime.ShowAlert("success", $"Chart saved successfully!", false, 2600); }
        else { await _jsRuntime.ShowAlert("error", $"Chart failed to save! Try again.", true); }

    }

    private async Task OnClickSaveChartLocal()
    {
        await _jsRuntime.ShowLoading();

        //check if number of charts exceed 3 (real 4), as that seems to be chrome limit
        var savedChartCount = (await GetSavedChartNameList()).Count;
        if (savedChartCount > 3)
        {
            await _jsRuntime.ShowAlert("success", $"Saved charts is full!", false, 2600);
        }

        //a name to uniquely identify this chart
        var chartName = $"{SelectedPerson.Id}|{StartTime.GetStdYear()}-{EndTime.GetStdYear()}|Chart|{SelectedPerson.Name}"; //"Chart" important used later to find
        await _jsRuntime.SetProperty(chartName, _finalSvg);

        _jsRuntime.HideLoading();

        //show message to user
        await _jsRuntime.ShowAlert("success", $"Chart saved successfully!", false, 2600);

    }


    /// <summary>
    /// when user clicked tab saved tab, refresh saved list immediately
    /// </summary>
    /// <returns></returns>
    public async Task<List<string>> GetSavedChartNameListLocal()
    {
        //get all latest keys from browser
        var allKeys = await _jsRuntime.InvokeAsync<List<string>>("getAllLocalStorageKeys");

        //find the keys that hold the needed charts
        var filtered = allKeys.Where(x => x.Contains("Chart")).ToList();

        return filtered;
    }

    public async Task<List<XElement>> GetSavedChartNameList()
    {
        //get name list of all charts
        //note: API will return readable name & hash for finding the chart later
        var rootXml = await ServerManager.ReadFromServerXmlReply(ServerManager.GetSavedChartIdList, _jsRuntime);

        //<Root>
        //    <ChartName>
        //        <Name>Viknesh - 4/1994 to 3/2114</Name>
        //        <Hash>895183858</Hash>
        //    </ChartName>
        //</Root>
        var chartIdXmlList = rootXml.Elements().ToList();

        return chartIdXmlList;
    }



}
